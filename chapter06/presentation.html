<!DOCTYPE html>
<html>
  <head>
    <title>Kapitel 06: Architectural Design</title>
    <meta charset="utf-8">
    <style>
      body { 
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      h1 {
        font-size: 45px !important; /* h1 down to h2 */
      }
      h2 {
        font-size: 35px !important; /* h2 down to h3 */
      }
      h1#kapitel-06-architectural-design {
        font-size: 55px !important; /* "ignore" coverpage */
      }
      img {
        max-height: 681px;
        max-width: 100%;
      }
      .img-200 img { max-height: 200px; }
      .img-300 img { max-height: 300px; }
      .img-400 img { max-height: 400px; }
      .img-450 img { max-height: 450px; }
      .img-500 img { max-height: 500px; }
      .img-600 img { max-height: 600px; }
      .remark-code, .remark-inline-code { 
        font-family:Courier New;
      }
      @page {
        size: 908px 681px;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <textarea id="source">


class: center, middle




# Kapitel 06: Architectural Design

Leon Brandt

---

# Inhalt

- Einleitung
- Artefakt: Architectural Model
- Architectural Design Decisions
- Architectural Patterns (inkl. 5 Beispiele)
- Application Architectures (inkl. 3 Beispiele)

---

--- TODO: Einleitung ---

- Definition
- Motivation
- Abgrenzung Requirements Engineering
- Abstraktionsebenen
- Relevanz

---

# Architectural Design

Architectural Design =

- Entwurf von Struktur und Organisation von Softwaresystemen
- Identifikation von strukturellen Hauptkomponenten eines Systems + Beziehungen dieser

Ergebnis: Artefakt: Architectural Model

---

# Motivation

- Auch in agilen Prozessen üblich: Früher Fokus auf Design von Gesamtsystemen im Entwicklungsprozess
- Inkrementelles Entwickeln von Architekturen ist (üblicherweise) nicht erfolgreich


- Refactoring einzelner Komponenten ist (üblicherweise relativ) einfach
- Refactoring einer Systemarchitektur erfordert (möglicherweise) ein Ändern mehrerer Komponenten

---

# Motivation

- Individuelle Komponenten implementieren funktionale Anforderungen eines Systems
- Dominanter Einflussfaktor auf nicht-Funktionale Anforderungen eines Systems ist dessen Architektur


- Architektur eines Systems bestimmt u.A. dessen Laufzeitperformanz, Robustheit, Verteilbarkeit, Wartbarkeit

---

# Motivation

- Explizites Benennen einer Systemarchitektur erfordert Analyse (Alternativen abwägen; Beste Lösung finden)


- Architectural Models können zur Kommunikation genutzt werden (mit Stakeholdern, anderen Entwicklern)


- Architekturen von Systemen mit ähnlichen Anforderungen können wiederverwendet werden

---

# Architectural Design vs. Requirements Engineering

- Praxis: Schnittmenge zwischen Requirements Engineering und Architectural Design


- Idealfall: Systemspezifikation (Was) enthält keine Designinformationen (Wie)
- Unrealistisch, da High-Level-Features eines Systems durch dessen Hauptkomponenten repräsentiert werden


- Bereits im Requirements Engineering möglich: Erzeugen einer abstrakten Systemarchitektur durch Gruppieren von Systemfeatures zu Subsystemen

---

# Abstraktionsebenen

Betrachtung von Softwarearchitektur auf zwei Ebenen:

## Architecture in the small

Architektur individueller Programme

*vs.*

## Architecture in the large

Architektur komplexer Systeme, also (verteilter) Systeme aus anderen Systemen, Programmen und Komponenten

---

--- TODO: Architectural Model ---

- Debatte über Formalität

---

# Architectural Model

Ein Architectural Model beschreibt die Organisation eines Systems als Menge von kommunizierenden Komponenten

#### Wie (formell) die Architektur eines Systems notieren?

---

# Architectural Model: Nutzung

Praxis: Nutzung von Architectural Models auf zwei Arten:

## Zum Entwurf

- Kommunikationshilfe im Designprozess
- Auch: Basis für Design in höherem Detailgrad
- Hier: High-Level-Repräsentationen nützlich

## Zur Dokumentation

- Dokumentation einer Architektur durch vollständiges Systemmodell
- Auch: Basis für Implementierung
- Hier: Strengere Notationen in hohem Detail- und Vollständigkeitsgrad

---

class: img-400

# Architectural Model: Formalität

- In der Praxis häufig: informelle Blockdiagramme

![](media/6_01.png)

[Fig. 6.1]

---

# Blockdiagramme

**Vorteile**
- Intuitiv verständlich für Menschen verschiedener Disziplinen
	- Kommunikation zwischen Ingenieuren und Domänenexperten
	- Nützlich für Manager zur Projektplanung


**Nachteile**
- Undetailliert
	- Typen von Beziehungen + äußere Eigenschaften von Komponenten fehlen
	- Raum für Missverständnisse

---

# UML?

- Umfrage: Wenn UML genutzt, dann meist informell
- UML soll objektorientierte Systeme beschreiben
- Sommerville: Zur Phase des Architekturdesigns sollten Systeme abstrakter beschrieben werden
- UML im Designprozess nicht nützlich

---

# Dokumentation durch strenge Notationen

- Es existieren spezialisierte Modellierungssprachen: Architectural Description Languages (ADLs)
	- Sind ohne Übung ggf. schwer nutzbar


- Grundsätzlich: Erzeugen von vollständigen, detaillierten Architekturdokumentationen ist teuer
- Kosteneffektivität lässt sich praktisch nicht messen &rarr; Ansatz nicht weit verbreitet

---

--- TODO: Architectural Model > Architectural Views ---

- 4 / 5 Views
- Praxisbezug

---

# Architectural Views

- Es ist nicht möglich, alle relevanten Informationen über eine Architektur auf einem einzelnen Diagramm darzustellen
- Grundsätzliche Frage bei Entwurf: Welche Perspektiven auf eine Systemarchitektur sind nützlich?
- Ein grafisches Modell kann nur eine Perspektive zeigen


- Krutchen schlägt vier fundamentale Architektur-Sichten vor
- Hofmeister et. al. ergänzen das Modell durch eine Fünfte

---

# Logical View (logische Sicht)

- Zeigt die wesentlichen Abstraktionen innerhalb des Systems als Objekte oder Objektklassen
- Zuordnung von Systemanforderungen zu Entities sollte hierbei möglich sein

---

# Process View (Prozesssicht)

- Zeigt wie das System zur Laufzeit aus interagierenden Prozessen zusammengesetzt ist
- u.A. nützlich zur Beurteilung von nicht-Funktionalen Charakteristiken wie Performance und Availability

---

# Development View (Entwicklungssicht)

- Zeigt wie die Software zur Entwicklung zerlegt ist
- Nützlich für Manager und Programmierer
	- Komponenten können einzelnen Entwicklern / Teams zugewiesen werden

---

# Physical View (physische Sicht)

- Zeigt Hardware und Verteilung von Komponenten über die Prozessoren im System
- Nützlich für Systemingenieure zur Planung von Deployments

---

# Conceptual View (konzeptionelle Sicht)

- Abstrakte Sicht des Systems
- Nutzung zur Zerlegung von High-Level-Anforderungen in detaillierte Spezifikationen
- Kann bei Identifikation von wiedeverwendbaren Komponenten helfen

---

# Architectural Views

(nach Krutchen)

- Logical View (logische Sicht)
- Process View (Prozesssicht)
- Development View (Entwicklungssicht)
- Physical View (physische Sicht)

(nach Hofmeister et. al.)

- Conceptual View (konzeptionelle Sicht)

---

# Architectural Views

Praxis: Nutzen der Sichten nach Bedarf (die, die zur Kommunikation nützlich sind)

Sommerville: Vollständigkeit nicht von Bedeutung

---

--- TODO: Architectural Design Decisions ---

- 8 Fragestellungen

---

# Architectural Design Decisions

- Architectural Design ist ein kreativer Prozess
- Entwurf der Organisation eines Systems, sodass funktionale + nicht-funktionale Anforderungen erfüllt werden
- Es existiert kein stereotyper Prozess
- Konkreter Prozess ist abhängig von zu entwickelnden System (Typ, spezifische Anforderungen)


- Architectural Design ist keine Sequenz von Aktivitäten
- Besseres Konzept: Menge an zu treffenden Entscheindungen

---

# Architectural Design Decisions

![](media/6_02.png)

[Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_1a.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_1b.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_2a.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_2b.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_3a.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_3b.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_4a.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_4b.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_5a.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_5b.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Architectural Design Decisions

![](media/6_02_mod_full.png)

[Eigene Darstellung nach Fig. 6.2]

---

# Nicht-funktionale Anforderungen an Systeme

Konkrete Architektur eines Systems sollte von nicht-funktionalen Anforderungen an dieses abhängen

---

# Performance

#### (Laufzeitperformanz)

- Lokalisieren performanzkritischer Operationen auf eine geringe Anzahl an Komponenten
- Weniger, größere anstatt vieler, feingranularer Komponenten
- Reduktion von Kommunikation zwischen Komponenten verbessert Performance
- Auch: Parallelisierung

---

# Security

#### (Sicherheit hinsichtlich gezielter Störversuche)

- Geschichtete Struktur; kritische Assets weiter innen
- Hoher Grad an Security-Validierung innerhalb der Schichten

---

# Safety

#### (Sicherheit hinsichtlich der Umgebung)

- Safety-Relevante Vorgänge in gemeinsamer Komponente bzw. geringer Anzahl an Komponenten
- Reduziert Kosten hinsichtlich Validierung
- Verbundene Schutzsysteme können im Fehlerfall sicher abgeschaltet werden

---

# Availability

#### (Verfügbarkeit)

- Redundante Komponenten
- Ersetzen und Aktualisieren ohne Ausfallzeiten

---

# Maintainability

#### (Wartbarkeit)

- Fein-granulare bzw. self-contained (unabhängige) Komponenten
- Trennung von Erzeugern von Daten und Konsumenten von Daten
- Vermeidung verteilter Datenstrukturen

---

# Nicht-funktionale Anforderungen an Systeme

- größere Komponenten verbessern Performance
- kleinere Komponenten verbessern Maintainability


- mehr Validierung verbessert Security
- weniger (redundante) Validierung verbessert Safety


- Grundsätzlich: Kompromisse zwischen Anforderungen
- Möglich: Unterschiedliche Ansätze für verschiedene Teile eines Systems

---

# Bewertung von Architekturdesigns

- Test einer Architektur = Genügung des Systems hinsichtlich funktionaler + nicht-funktionaler Anforderungen im Betrieb
- Evaluation schwierig
- Vergleich mit Referenzarchitekturen oder Pattern möglich

---

--- TODO: Architectural Patterns ---

- Einleitung
- Einordnung

---

# Architectural Patterns

- Pattern erlauben Präsentieren, Teilen und Wiederverwenden von Wissen
- Architectural Pattern = Abstrakte Beschreibung von Praktiken, die sich in verschiedenen Systemen / Umgebungen bewährt haben
- Beschreiben Organisation entsprechender Systeme sowie Stärken + Schwächen

---

# Model-View-Controller (MVC)

#### Beschreibung

- Seperiert Präsentation und Interaktion von Daten
- Drei logische Komponenten:
	- Model (verwaltet Daten, implementiert Operationen auf diesen)
	- View (definiert + verwaltet Präsentation der Daten)
	- Controller (verwaltet Benutzerinteraktion, leitet diese an View und Model)

---

class: img-450

# Model-View-Controller (MVC)

![](media/6_05.png)

[Fig. 6.5]

---

# Model-View-Controller (MVC)

#### Verwendung

- Wenn es mehrere Wege gibt, Daten zu betrachten und mit diesen zu interagieren
- Wenn Zukünftige Anforderungen für Interaktion und Datenpräsentation unbekannt sind

---

# Model-View-Controller (MVC)

#### Vorteile

- Erlaubt Änderungen am Datenmodell unabhängig von der Präsentation (sowie umgekehrt)
- Erlaubt verschiedene Präsentationen der selben Daten
- Änderungen von Daten in einer Präsentation wirken sich unmittelbar auf alle aus

#### Nachteile

- Erzeugt zusätzlichen Code und damit Komplexität
- Auch, wenn Datenmodell und Interaktion simpel sind

---

# Layered Architecture

#### Beschreibung

- Organisation in Schichten, welche zusammengehörige Funktionalitäten implementieren
- Eine Schicht stellt der Schicht über ihr Services zur Verfügung (Jede Schicht erfordert nur die direkt unterhalb)
- Unterste Schicht repräsentiert Core-Funktionalitäten

---

class: img-450

# Layered Architecture

![](media/6_08.png)

[Fig. 6.8]

---

# Layered Architecture

#### Verwendung

- Wenn Funktionalitäten auf Basis existierender Systeme hinzugefügt werden sollen
- Nützlich bei Verteilung der Entwicklung über mehrere Personen / Teams
- Bei Anforderungen an Security

---

# Layered Architecture

#### Vorteile

- Einzelne Schichten sind austauschbar und portabel (solange Interfaces zu abhängiger / höherer Schicht gleich)
- Bei Änderungen im Interface nur eine Schicht betroffen
- Redundante Funktionalitäten in mehreren Schichten verbessern Dependability
- Unterstützt inkrementelle Entwicklung (innenliegende Services können bereits während Entwicklung bereitgestellt werden)
- Erleichtert Multi-Plattform-Implementierungen (Maschinenabhängigkeiten können lokal auf einer Schicht gehalten werden)

#### Nachteile

- Praxis: saubere Seperation von Schichten häufig schwierig
- Schichten müssen ggf. über mehrere Ebenen direkt interagieren (nicht via Stapel an Schichten dazwischen)
- Mehrere Level der Verarbeitung kann Performance negativ beeinträchtigen

---

# Repository Architecture

#### Beschreibung

- Daten / Zustand wird innerhalb eines zentralen Repositories verwaltet
- Komponenten interagieren nur durch das Repository mit Daten, niemals direkt


- Varianten der Steuerung:
	- Passiv (Komponenten steuern Zugriff)
	- Aktiv (z.B. Trigger bei Verfügbar-werden von Daten)

---

class: img-450

# Repository Architecture

![](media/6_11.png)

[Fig. 6.11]

---

# Repository Architecture

#### Verwendung

- Systeme, die große Mengen von Informationen erzeugen, die persistiert werden müssen
- Bei Data-Driven-Systems, die bei Hinzufügen von Daten Aktionen auslösen
- Anwendungen, bei denen eine Komponente Daten generiert und eine Andere diese nutzt

---

# Repository Architecture

#### Vorteile

- Komponenten sind unabhängig (müssen nichts von der Existenz von Anderen wissen, da keine explizite Kommunikation zwischen Komponenten)
- Datenänderungen innerhalb einer Komponente wirken sich global auf alle Komponenten aus
- Daten sind durchgehend konsistent (vereinfacht z.B. Erstellen von Backups)

#### Nachteile

- Repositories sind single point of failure (Probleme im Repository betreffen ganzes System)
- Große Teile der Kommunikation via Repository kann ineffizient sein
- Verteilung von Repositories erfordert Verwalten mehrerer Kopien und Herstellen von Konsistenz (Overhead)
- Zentrales Repository-Datenmodell erforderlich (Kompromiss zwischen spezifischen Anforderungen in Komponenten; Integration schwierig bei Inkompabilität)

---

# Client-Server-Architecture

#### Beschreibung

- Systeme sind Menge an:
	- Services, die von Servern zur Verfügung gestellt werden
	- Clients, die über ein Netzwerk Services nutzen


- Server sind Softwarekomponenten, die Services anbieten
- Mehrere Server können auf einem Rechner ausgeführt werden
- Üblich: viele Instanzen von Client-Programmen parallel auf vielen Computern
- Üblich: Implementierung als verteiltes System (jedoch auch lokal auf einem Rechner möglich)


- Clients müssen verfügbare Server sowie deren Services kennen
- Server müssen weder Identitäten noch Anzahl der Clients kennen

---

class: img-450

# Client-Server-Architecture

![](media/6_13.png)

[Fig. 6.13]

---

# Client-Server-Architecture

#### Verwendung

- Wenn Daten in einer geteilten Datenbank von verschiedenen Orten abgerufen werden müssen
- Wenn Last auf ein System variable ist (Server können repliziert werden)

---

# Client-Server-Architecture

#### Vorteile

- Generelle Funktionalitäten müssen nicht durch jeden Client implementiert werden (Bereitstellung durch Server)
- Hinzufügen /Integration neuer Server ist einfach
- Aktualisieren von Servern ist möglich, ohne andere Teile eines Systems zu beeinflussen

#### Nachteile

- Jeder Service ist single point of failure (DoS-Attacken, Server-Fehler)
- Performance unvorhersehbar, das abhängig von System und Netzwerk

---

# Pipe-and-Filter-Architecture

#### Beschreibung

- Verarbeitungseinheiten (Filter) führen einen Typ von Datentransformationen durch
- Daten fließen in "Pipes" zur Verarbeitung von einer Komponente zur Nächsten (sequentiell/parallel; elementweise/batchweise)

---

class: img-450

# Pipe-and-Filter-Architecture

![](media/6_15.png)

[Fig. 6.15]

---

# Pipe-and-Filter-Architecture

#### Verwendung

- Wenn Daten in seperaten Schritten verarbeitet werden
- Bei Batch-Processing und eingebettete Systeme (ohne Benutzerinteraktion)

---

# Pipe-and-Filter-Architecture

#### Vorteile

- Einfach zu verstehen
- Wiederverwenden einzelner Transformations-Komponenten möglich
- Art der Verarbeitung entspricht der Art der Struktur vieler Businessprozesse
- Weiterentwicklung durch Hinzufügen von Transformationen ist simpel

#### Nachteile

- Abstimmung von Datenformaten zwischen kommunizierenden Komponenten
- Jede Transformation muss Input parsen und interpretieren sowie Output unparsen (Overhead)
- Bei Wiederverwendung ggf. Herstellen von Kompabilität

---

--- TODO: Einordnung ---

---

--- TODO: Application Architectures ---

- Einleitung
- Arten der Nutzung

---

--- TODO: Application Architectures > Transaction-Processing-Systems ---

---

--- TODO: Application Architectures > Information Systems ---

---

--- TODO: Application Architectures > Language-Processing-Systems ---

    </textarea>
    <script src="../_assets/js/remark-latest.min.js">
    </script>
    <script>
    
    var slideshow = remark.create({
  // Set the slideshow display ratio
  // Default: '4:3'
  // Alternatives: '16:9', ...
  ratio: '4:3',

  // Navigation options
  navigation: {
    // Enable or disable navigating using scroll
    // Default: true
    // Alternatives: false
    scroll: true,

    // Enable or disable navigation using touch
    // Default: true
    // Alternatives: false
    touch: true,

    // Enable or disable navigation using click
    // Default: false
    // Alternatives: true
    click: false
  },

  // Customize slide number label, either using a format string..
  slideNumberFormat: 'Slide %current% of %total%',
  // .. or by using a format function
  slideNumberFormat: function (current, total) {
    return '' + current + '/' + total;
  },

  // Enable or disable counting of incremental slides in the slide counting
  countIncrementalSlides: true
}); 
    
    
      
    </script>
  </body>
</html>
