<!DOCTYPE html>
<html>
  <head>
    <title>Software processes</title>
    <meta charset="utf-8">
    <style>
      body { 
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { 
        font-family:Courier New;
      }
      @page {
        size: 908px 681px;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <textarea id="source">


class: center, middle




# Kapitel 02: Software processes

Artem Shipilov

---

## Agenda
  <br><br><br>
- Ziele
- Einführung
- Software-Prozessmodelle
 - Das Wasserfallmodell
 - Inkrementelle Entwicklung
 - Integration und Konfiguration
- Prozessaktivitäten
 - Softwarespezifikation 
 - Softwaredesign und Implementierung
 - Softwarevalidierung      
 - Software evolution
- Umgang mit Veränderungen
 - Prototyping
 - Inkrementelle Lieferung
- Prozessverbesserung      
      
---
      
## Ziele:
<br>
* die **Konzepte von Softwareprozessen** und -modellen verstehen;
* wann **3 allgemeinen Software-Prozessmodelle** verwendet werden können;
* die **grundlegenden Prozessaktivitäten** kennen;
* verstehen, **warum** Prozesse **organisiert** werden sollten;
* den Begriff der **Softwareprozessverbesserung** und die Faktoren verstehen.

---
      
## Einführung    

**Software Process** - Menge von Aktivitäten --> Softwareproduktion

die Software Systeme - zu unterschiedlich <br>
-> Es gibt keine allgemeingültige Software Engineering Methode <br>
--> Es gibt keinen ideallen Software Prozess    
      
---    
grundlegende Abläufe, die alle Softwareprozesse haben:
<br>
* **1. Softwarespezifikation.** - Anforderungen aufnehmen.
* **2. Softwareentwicklung.** - Anforderungen umsetzen.
* **3. Softwarevalidierung.** - Überprüfen, ob der Kund zufrieden ist.
* **4. Weiterentwicklung von Software.** Veränderte Bedürfnissen des Kunden --> Arbeit.
      
---
      
## Einführung      
      
Aktivität setzt sich aus:
1. **Produkte oder Leistungen** - die Ergebnisse einer Prozessaktivität.
2. **Rollen** - Verantwortlickeit festlegen.
3. **Vor- und Nachbedingungen** - sind die Bedingungen bevor und nachdem die Prozesstätigkeit. <br> 
      (z.b. Vorbedingung - Zustimmung von Anforderungen; <br>
      Nachbedingung - Validierung der UML-Modelle.)
      
**unterschiedliche Prozesstypen:**
- Sicherheitskritische Systeme
 - Stark Strukturierter Prozess nötig
-	Anwendungen mit hoher Frequenz bei neuen Anforderungen
 -	flexibler, agiler Prozess
- Bei großen Systemen 
 - ein Gleichgewicht zwischen geplanter und agiler Entwicklung

Unternehmen können der Software Prozess weiter optimieren.
      
---
      
## 1. Software-Prozessmodelle
<br><br>
Prozessmodelle (abstrakte Beschreibungen, ohne Details über einzelne Aktivitäten im Prozess):
-	Wasserfallmodell
 - Prozessaktivitäten - als seperate Phasen
-	Inkrementelles Modell
 - Verknüpfung aller Aktivitäten und inkrementelle Entwicklung
-	Integration & Configuration
 -	Entwicklung von wiederverwendbaren Softwaremodulen
      
---
      
## Das Wasserfallmodell - Einführung
      
*	Abgeleitet aus einem Entwiclungsprozessen für große militärische Projekte
*	Prozess als **stufenweise** Abfolge von Aktivitäten
*	Plan-driven Prozess
* Jede Stufe - eine Aktivität     
<div style="margin-top:60px;">
  <img style="width:100%;" src="img/01.png"/>
</div> 

---
      
## Das Wasserfallmodell - Beschreibung     

-	Anforderungsdefinition:
 -	grundliegende Anforderungen --> Systemspezifikation
-	System- und Softwaredesign:
 -	Softwarespezifikation --> Softwareentwurf (grundlegende Bestandteile und Beziehungen)
-	Implementierung und Unit-Tests:
 -	Softwareentwurf --> eine Menge an Programmen
 -	Test der Software auf Unit Ebene --> funktionsfähige Softwaremodulen
-	Integration- und Systemtest:
 -	Test des Gesamtsystems (bestehend aus den Softwaremodulen) --> betriebsbereite Software
-	Betrieb und Instandhaltung:
 -	produktiver Betrieb
 -	Behebung von Fehlern
 -	Weiterentwicklung auf Basis<br> neuer Anforderungen

<div style="position:absolute; bottom:30px; right:20px; width:50%;">
  <img style="width:100%;" src="img/01.png"/>
</div>  
<br>
      
---
      
## Das Wasserfallmodell - Beschreibung 
      
1. Das Ergebnis jeder Stufe --> genehmigte Dokumente.
2. Die nächste Phase beginnt nicht, bevor die vorherige abgeschlossen wurde.
3. Hohe Herstellungskosten --> teuere Iterationen von Entwicklungsaktivitäten.     
4. Sinnvoll für die Hardwareentwicklung mit der hohe Herstellungskosten. <br>
      
Im Vergleich zu Hardwareentwicklung, wo Phasen klar abgegrenzt werden können, überschneiden sich bei Softwareentwicklung die Phasen. <br>
(Bspw. werden bei der Implementierung möglicherweise Fehler im Softwareentwurf gefunden)
      
---
      
## Das Wasserfallmodell - Beschreibung       

Veränderungen an den Anforderungen --> erheblichen Verlangsamung des Prozesses. <br>      
Kunden/Entwickler können die Softwarespezifikation einfrieren --> um weitere Änderungen zu verhindern.
Das bedeutet, dass:
* Probleme später gelöst/ignoriert/programmiert werden --> schlecht strukturierte Systemen
* kann dazu führen, dass das System nicht das tut, was der Benutzer wünscht. 

die Softwarewartung kann zur Folge haben:
- dass einige oder alle der vorherigen Prozessphasen wiederholt werden müssen.
 - Daher die Anforderungen sollen gut durchdacht sein.   
      
---

## Das Wasserfallmodell - Anwendung      

Aufgrund der Notwendigkeit, das System bei Änderungen frühzeitig zu verfeinern,
      ist das Wasserfallmodell nur für einige Arten von Systemen geeignet:
- Eingebettete Systeme (Software interagiert mit Hardwaresystemen).      
- Kritische Systeme. (umfängliche Sicherheitsanalyse der Softwarespezifikation/Softwareentwurfs nötig ist, 
      erst danach entwickelt werden).     
- Große Softwaresysteme, die Teil umfassenderer technischer Systeme sind, die von mehreren Partnerunternehmen entwickelt wurden. <br>
      Hardware in Systemen kann nach einem ähnlichen Modell entworfen werden. <br>
      -> gemeinsames Modell für Hardware und Software. <br>
      --> eine unabhängige Entwicklung der verschiedenen Subsysteme möglich. <br>
      
---
      
## Das Wasserfallmodell - Kontraindikationen
      
Das Wasserfallmodell ist kein geeignetes Vorgehensmodell wenn:
- eine informelle Teamkommunikation möglich ist --> die Softwareanforderungen schnell ändern sich. 
- Systementwicklung mit kleinem Budget
    
**Hohe Kosten für die Entwicklung** einer formalen Spezifikation --> Entwicklungsmodell **selten verwendet.**
      
---
      
## Inkrementelle Entwicklung      
      
Software wird über mehrere Versionen entwickelt.
-	Erste Implementierung --> Feedback des Kunden --> Weiterentwicklung
- Aktivitäten des Prozess - eng verknüpft
-	schneller Austausch zwischen den Aktivitäten ist daher möglich
-	heutzutage Häufigster Ansatz
      
<div style="margin-top:60px;">
  <img style="width:100%;" src="img/02.png"/>
</div>       
      
---
      
## Inkrementelle Entwicklung - Vorteile      
      
-	Umsetzung: Plan-driven/Agil/Kombination
 -	Plan-driven: Festlegung aller zu lieferenden Inkremente
 -	Agil: erste Inkremente festlegen --> dynamisch auf Anforderungen des Kunden reagieren     
-	"Natürlicher" Weg des Problem lösen
 -	Im Alltag erarbeitende Lösung eines Problems (nicht im vorhinein)
 -  Lösung in Schritten
-	Geringere Kosten für Änderung an Anforderungen (weniger Aufwand für Analyse und Dokumentation)
-	Feedback ist leichter einzuholen (der Kunde regelmäßig Inkremente sieht)
-	vorzeitige Lieferung und Bereitstellung ist möglich, auch wenn nicht alle Funktionen enthalten sind
      
---
     
## Inkrementelle Entwicklung - Nachteile 
      
aus Sicht des Management:
-	Systeme schnell entwickelt werden <br>
 -> ist es nicht kosteneffektiv, jede Version zu dokumentieren <br>
 --> Der Entwicklungsprozess ist nicht sichtbar
- Die Systeme sind oft schlecht strukturiert. <br>
 Softwareänderungen - zunehmend schwerer und teurer. <br> 
 Code - schlechter. <br>
 Bei großen Projekte --> einheitliche Architektur & stabiler Entwicklungsrahmen.
      
- spezielle Werkzeuge und Techniken <br>
  -> schnelle Entwicklung <br>
  --> Inkompatibilität mit anderen Werkzeugen oder Techniken <br> 
  ---> wenige Leute wissen, wie man mit ihnen umgeht
-	Feedback von Kunden <br> 
   -> Experimentieren mit neuer Software <br>
   --> Störung von normalen Geschäftsprozessen
      
---
      
## Integration und Konfiguration   
      
Wiederverwendung wird oft benutzt der Softwareentwicklung.
      
informelle Wiederverwendung --> seit Jahr 2000 weit verbreitet --> offizieller Softwareprozess
      
Drei Arten von wiederverwendete Softwarekomponenten:
1. **Eigenständige Anwendungssysteme,** - Verwendung in einer bestimmten Umgebung. <br>
      Allzwecksysteme, müssen jedoch angepasst werden.
2. **Sammlungen von Objekten,** (Komponente/Paket) - werden in einem Komponenten-Framework integriert.
3. **Webdienste** (gemäß Dienststandards) - für den Fernaufruf über das Internet    
      
<div style="margin-top:20px;">
  <img style="width:100%;" src="img/03.png"/>
</div>   
      
---
      
## Integration und Konfiguration - Phasen
      
1. **Anforderungsspezifikation** - Aufnahme gründlegender Anforderungen (ohne Details)
2.	**Software-Erkennung und -Evaluierung** <br>
  Suche nach Komponenten, welche den Anforderungen genügen <br>
  Systeme bewerten, beurteilen --> mit die Anforderungen geeignet sind.
3.	**Verfeinerung der Anforderungen** - Berücksichtigung der gefundenen Komponente <br>
  Wenn nichts gefunden wurde --> Rücksprung zur Anforderungsspezifikation um mögliche andere Lösungen zu suchen.
4.	**Konfiguration des Anwenungssystems** - sofern die Anforderungen sich mit dem Standardsystem umsetzen lässt
5.	**Komponentenanpassung und Integration** - wenn es kein Standartsystem gibt --> einzelne Komponente modifizieren und integrieren.

<div style="margin-top:20px;">
  <img style="width:100%;" src="img/03.png"/>
</div>
      
---
      
## Integration und Konfiguration - Zusammenfassung      
      
-	Erheblicher Vorteil: <br>
1. Umfang der zu entwickelnden Software wird stark reduziert
2. 	geringere Kosten und Zeit
      
-	Nachteil
1.	Kompromisse bei der Anforderungsanalyse. Ergebnis möglicherweise - nicht das was der Kunde möchte.
2.	Kontrolle über Gesamtsystem schwierig (Harmonie verschiedener Komponenten Versionen untereinander).
      
---
      
## 2. Prozessaktivitäten
      
Prozess - eine verschachtelte Abfolge von technischen, kollaborativen und Managementaktivitäten.
      
Gesamtziel: Spezifikation -> Entwurf -> Implementierung -> Test
      
Grundlegende Prozessaktivitäten:
      1. Spezifikation
      2. Entwicklung
      3. Validierung
      4. Evolution
      
Wie die Aktivitäten durchgeführt werden, hängt ab von:
      1.	Art der entwickelnden Software
      2.	Erfahrung/Kompetenz der Entwickler
      3.	Art der Organisation
      
---
      
## Softwarespezifikation (Requirements Engineering)

- Definition: <br>
1. der Prozess des Verstehens, welche Funktionen benötigt werden.      
2. Kritische Phase --> Fehler bei der Aktivität sind besonders teuer <br>
      --> können sich in den folgenden Phase vergrößern.
      
- Vor der Anforderungsanalyse: <br>
Machbarkeitstudie/Durchführbarkeitsstudie -	kurze Studien ob es einen Bedarf/Markt gibt für das Produkt und finanziell/zeitlich realistisch.

- Ziel: <br>
Vereinbarung eines Anforderungsdokument (Systemspezifikation/Kundenanforderungen)

- Zwei Ebenen der	Anforderungen:
1. für End-User/Kunde: high level Anforderungen
2. für Entwickler: mehr detalierte System spezifische Anforderungen
      
---
      
## Softwarespezifikation      
     
3 Hauptaktivitäten im Requirements Engineering:
      
<div style="position:absolute; top:70px; right:10px; width:45%;">
  <img style="width:100%;" src="img/04.png"/>
</div> 
      
-	Anforderungserhebung und Analyse
 -	Aufnahme von Anforderungen
 -	Beobachten von bestehenden Systemen
 -	Gespräche mit Nutzern
 -	Aufgabenanalyse
 -	Entwicklung von Prototypen (möglich)
-	Anforderungsspezifikation
 -	Gesammelte Information in einem Dokument
 -	Formulierung von Anforderungen auf End-User Level (Kunde) und Systemlevel (Entwickler)
-	Anforderungsvalidierung
 -	Überprüfung der aufgenommenen Anforderungen hinsichtlich Umsetzbarkeit und vollständigkeit
 -	Aktivität soll Qualität sicherstellen --> Fehler finden
      
Aktivitäten (verschachtelt) laufen während der Analyse weiter <br> 
      Anforderungen mit der Zeit --> weiter verfeinert
      
---
      
## Softwaredesign und Implementierung      
     
**Ziel:** eine ausführbare Software zu liefern.
      
Abhängig von Prozess Modell können die Aktivitäten getrennt vorhanden sein
      
Softwareentwurf - Beschreibung der Struktur von:
- implementierenden Software
- der verwendeten Datenmodelle und -Strukturen
- (selten) der Schnittstellen zwischen Systemkomponenten/Algorithmen
      
Infos über die Software Plattform (wo die Software ausgeführt wird) - wichtiger Teil für den Designprozess,
da muss man wissen, wie man die Prozesse integrieren soll. --> Plattformspezifikation/Entwurfsprozess.

Die Aktivitäten im Designprozess hängen von entwickelndem System.      
      
---
      
## Softwaredesign und Implementierung
<br><br><br>     
Aktivitäten (Teil des Entwurfsprozesses):
      
1. Architekturenentwurf: <br>
-Gesamtstruktur des Systems <br>
-Komponenten, ihre Beziehungen/Verteilung.
2. Datenbankdesign: <br>
-Systemdatenstrukturen und wie die darstellen. <br>
(Datenbank wiederverwenden/neue erstellen)
3. Schnittstellendesign: <br>
Schnittstellen zwischen Systemkomponenten. <br>
-Schnittstellenspezifikation. <br>
-die Komponenten separat entwerfen <br>
& entwickeln.
4. wiederverwendbaren Komponenten. <br>
-wenn es keine gibt --> neue Softwarekomponente entwerfen. <br>
-einfache Komponentenbeschreibung / detaillierte Implementierungsdetails (Liste mit Änderungen / Designmodell mit UML Druck)      
      
<div style="position:absolute; top:120px; right:0px; width:45%;">
  <img style="width:100%;" src="img/05.2.png"/>
</div>       
      
---
      
## Softwaredesign und Implementierung      
      
Aktivitäten --> Entwurfsergebnissen.

- Bei modellgetriebener Ansatz - die Entwurfsergebnisse in Entwurfsdiagrammen aufgeführt. 
- Bei agile Entwicklungsmethoden - die Ergebnisse keine separaten Spezifikationsdokumente haben (im Code des Programms)

Systemdesign --> Entwicklung <br>
-> Tests des Codes  -> Programmfehler (Bugs) -> Debuggen

Fehlerprüfung und Fehlerbeseitigung - unterschiedliche Prozesse.      
      
---
      
## Softwarevalidierung - Phasen
      
Validierungstechnik - Programmtests (unter Verwendung der Testdaten).  <br>
Überprüfungsprozesse sind möglich (Inspektionen und Überprüfungen in jeder Phase) 

- Meiste Zeit --> Test von Programmen.           
- Integriertes System wird auch getestet.
- Benutzertest heißt Beta-Test --> Benutzerkommentare
    
Die Phasen des Testprozesses:
1. **Komponententests.** -  jede Komponente unabhängig von anderen getestet. <br>
Bespiel für ein Komponent - Funktionen oder Klassen. 
2. **Systemtest.** Komponenten --> Gesamtsystem. <br>
(nicth)funktionale Anforderungen erfüllen. <br>
Bei großen Systemen - mehrstufiger Prozess (Test von Subkomponenten).
3. **Kundentests.** - von Systemkunden, mit realen Daten.    
   
<div style="margin-top:20px;">
  <img style="width:80%;" src="img/06.png"/>
</div>  
      
---
      
## Softwarevalidierung  
      
- Bei einer testgetriebener Entwicklung: <br>
die Tests mit den Anforderungen --> Entwicklung 
- Bei plangesteuertes Softwareprozess: <br>
Testplänen (aus der Systemspezifikation) --> Tests
- In der Abbildung: Testpläne - Verbindung zwischen Test und Entwicklungsaktivitäten (V-Modell). 
- **V-Modell** - die Software-Validierungsaktivitäten, die jeder Stufe des WasserfallsProzessmodells entsprechen. 
- Beta-Testing ist möglich
      
<div style="margin-top:20px;">
  <img style="width:100%;" src="img/07.png"/>
</div>      
      
---
      
## Software evolution
      
- viel sinnvoller eine Änderungen an der Software vorzunehmen als an der Systemhardware.

Es gibt der Prozess namens Softwareevolution (Softwarewartung).

- meist wird Softwareevolution als ein zusammenhängendes Prozess angesehen. 
- Man sollte es aber lieber als ein getrenntes Prozess vorstellen (siehe Abbildung). 

Hier ist die Software - Reaktion auf änderte Anforderungen und Kundenbedürfnisse.
      
<div style="margin-top:20px;">
  <img style="width:100%;" src="img/08.png"/>
</div>      
      
---
      
## 3. Umgang mit Veränderungen

Die Änderungen tragen **hohe Kosten** mit sich, weil:
- Anforderungsanalyse wiederholen (ganz/teilweise)
- (manchmal) alle Programme ändern --> System neu testen      

Ansätze, um die Kosten der Nacharbeit zu reduzieren:
1. **Erwartung ändern.** 
z.b. ein Prototypsystem entwickeln <br> 
--> Kunden die Merkmale des Systems zeigen --> Anforderungen verfeinern.
2. **Änderungstoleranz.** 
inkrementelle Form von Entwicklung - die vorgeschlagenen Änderungen in Schritten implementieren. <br>
(Monolith -> Modulith -> Microservice)

Möglichkeiten, mit Veränderungen umzugehen:
1. **System-Prototyping.** - schnelle Entwicklung einer Version des Systems(teils). <br>
-die Anforderungen / die Machbarkeit von Designentscheidungen prüfen.
2. **Inkrementelle Lieferung.** <br>
die Systeminkremente --> dem Kunden zur Kommentierung / Experimentieren.
- Änderungsvermeidung 
- die vorzeitige Festlegung von Anforderungen für das gesamte System
- Refactoring - die Struktur und Organisation von Programmen unterstützen      
      
---
      
## Prototyping
      
**Prototyp** - eine frühe Version eines Softwaresystems, das wird oft bei Konzeption demonstriert. <br>
--> Designoptionen / mögliche Lösungen

**Ziel:** erforderliche Änderungen vorherzusehen:
1. Im Requirements-Engineering: Erhebung/Validierung von Systemanforderungen.
2. Im Systemdesignprozess: Softwarelösungen/Schnittstelle

Im Software Engineering: erst ein/mehrere Prototypen --> ein Softwaresystem <br>
Auch Designexperimente --> Machbarkeit vorgeschlagenes Designs. <br>
z.b. Prototyp von Datenbankdesign --> Überprüfung vom Datenzugriff für die Benutzerabfragen --> Benutzerschnittstellen. 
  
---
      
## Prototyping
      
Die Ziele des Prototyping sollen von Beginn des Prozesses eingeplant werden.      
      
Ohne Ziele - schwierig die Funktionen verstehen. 

Die nächste Phase: was in das Prototyp eingefügt/weggelassen soll. --> Kostensenkung

Die letzte Phase: Evaluierung des Prototyps. 

Ein allgemeines Problem: Verwendenung von Prototyp nicht  wie endgültige System.
      
<div style="margin-top:20px;">
  <img style="width:100%;" src="img/09.png"/>
</div>  
      
---
      
## Inkrementelle Lieferung
      
Das ist ein Ansatz zur Softwareentwicklung, bei dem einige der entwickelten Inkremente 
      an den Kunden geliefert und dort eingesetzt werden.  <br>
-> welche der Services sind dür sie wichtig/unwichtig --> die Lieferinkremente

die Dienste mit der höchsten Priorität - zuerst
 
Während der Entwicklung --> (kann) weitere Anforderungsanalyse für spätere Inkremente (nicht zum aktuellen).      
      
<div style="margin-top:20px;">
  <img style="width:100%;" src="img/10.png"/>
</div> 
      
---
      
## Inkrementelle Lieferung - Vorteile   
      
1. Inkrement fertiggestellt -->
2. bei dem Kunden installiert -->
3. Sie experimentieren mit dem System -->
4. Anforderungen für spätere Systemerweiterungen --> 
5. neue Inkremente --> 
6. Integrierung mit bestehenden Inkrementen

Vorteile von inkrementellen Lieferung:
1. frühen Inkremente - als Prototypen verwenden <br>
--> Anforderungen für spätere Systemerweiterungen <br>
--> Im Gegensatz zu Prototypen sind Inkremente Teil des realen Systems <br>
--> vollständige System verfügbar --> kein Umlernen
2. Das erste Inkrement erfüllt wichtigsten Anforderungen der Kunden <br>
-->  sie verwenden die Software sofort
3. Alle Vorteile der inkrementellen Entwicklung <br>
--> relativ einfach Änderungen zu integrieren
4. Die wichtigsten Systemdienste werden am meisten getestet. <br>
--> weniger wahrscheinlich von Softwarefehler
      
---
      
## Inkrementelle Lieferung - Nachteile       
      
1. Problematisch, das **bestehende System durch ein neues ersetzen.** <br>
-Die Benutzer brauchen alle Funktionen des alten Systems <br>
-Sie sind nicht bereit das neue System zu testen <br>
-Man soll nicht das alte und das neue System nebeneinander verwenden <br>
--> unterschiedliche Datenbanken / Benutzeroberflächen
2. Schwierig, **gemeinsame Einrichtungen zu identifizieren,** die von allen Inkrementen benötigt werden.
3. **Spezifikation & Software werden zusammen entwickelt.** <br>
--> keine vollständige Systemspezifikation, bis das endgültige Inkrement spezifiziert ist. <br>
--> erfordert eine neue Vertragsform - für Großkunden/ Regierungsbehörden schwierig      
            
---
      
## Prozessverbesserung
      
Es gibt eine Nachfrage nach billigerer, besserer Software -  in kürzeren Fristen

Ansätze zur Prozessverbesserung: 
- **Der Prozessreife Ansatz:**
 -  Verbesserung von Prozess- und Projektmanagement. 
 -  Einführung guter Softwareengineering Praktiken.
      
**Ziele:** bessere Produktqualität und Prozessvorhersagbarkeit.
      
- **Der agile Ansatz** 
 -  iterative Entwicklung 
 -  Reduzierung von Gemeinkosten.
      
**Ziele:** schnelle Bereitstellung von Funktionen und die Reaktionsfähigkeit auf sich ändernde Kundenanforderungen. 
- konzentrieren sich auf den zu entwickelnden Code
- reduzieren bewusst Formalität und Dokumentation. 

---
      
## Prozessverbesserung - Der Prozessreife Ansatz
      
Die Phasen in diesem Prozess sind:
1. **Prozessmessung:** ein/mehrere Attribute gemessen werden. <br>
--> Grundlage, ob Prozessverbesserungen wirksam/nicht. 
2. **Prozessanalyse:** --> Prozessschwächen und Engpässe. <br>
--> Prozessmodelle, die den Prozess beschreiben. (z.b. Schnelligkeit und Robustheit)
3. **Prozessänderung:** - Prozessschwächen beheben.            
<div style="margin-top:20px;">
  <img style="width:100%;" src="img/11.png"/>
</div>      
      
---      
      
## Prozessverbesserung - Stufen der Prozessreife
      
Die Ebenen im Prozessreifemodell sind:

1. **Initialisierung.** - der Umgang der Arbeit für Prozesse festlegen und mitteilen.
2. **Verwaltung.** Projektplan --> Projektziele.  Ressourcenmanagement und die Prozessüberwachung. 
3. **Definierung.** - Standardisierung/Einsatz von Prozessen.
4. **Quantitative Verwaltung.** Prozess- und Produktmessungen --> im Prozessmanagement
5. **Optimierung.** Prozess- und Produktmessungen --> Prozessverbesserung. Trends analysieren.

formelle Prozessverbesserung -->  Verbesserungen der Software-Engineering-Fähigkeiten. <br>
Aber für kleine Unternehmen - zu viel Overhead.      
      
<div style="margin-top:20px;">
  <img style="width:100%;" src="img/12.png"/>
</div>       
      
      
      

    </textarea>
    <script src="../_assets/js/remark-latest.min.js">
    </script>
    <script>
    
    var slideshow = remark.create({
  // Set the slideshow display ratio
  // Default: '4:3'
  // Alternatives: '16:9', ...
  ratio: '4:3',

  // Navigation options
  navigation: {
    // Enable or disable navigating using scroll
    // Default: true
    // Alternatives: false
    scroll: true,

    // Enable or disable navigation using touch
    // Default: true
    // Alternatives: false
    touch: true,

    // Enable or disable navigation using click
    // Default: false
    // Alternatives: true
    click: false
  },

  // Customize slide number label, either using a format string..
  slideNumberFormat: 'Slide %current% of %total%',
  // .. or by using a format function
  slideNumberFormat: function (current, total) {
    return '' + current + '/' + total;
  },

  // Enable or disable counting of incremental slides in the slide counting
  countIncrementalSlides: true
}); 
    
    
      
    </script>
  </body>
</html>
